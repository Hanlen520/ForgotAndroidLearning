# 每月整理-2019年4月

1. 一段时间内只有一个主目标，做好一件事

2. The only thing I know is that I know nothing。 我唯一所知道的事情就是我一无所知。

3. 全国一本率约10%，211率约3%, 985率约1.5%

4. 进制转换时，先转成十进制，再转成其他进制
 //十进制转成十六进制  Integer.toHexString(14);
 //十进制转成八进制    Integer.toOctalString(14);
 //十进制转成二进制    Integer.toBinaryString(12);

 //十六进制转成十进制  Integer.valueOf("FFFF",16).toString();
 //十六进制转成二进制   Integer.toBinaryString(Integer.valueOf("FFFF",16));
 //十六进制转成八进制  Integer.toOctalString(Integer.valueOf("FFFF",16));

 //八进制转成十进制    Integer.valueOf("576",8).toString();
 //八进制转成二进制    Integer.toBinaryString(Integer.valueOf("23",8));
 //八进制转成十六进制  Integer.toHexString(Integer.valueOf("23",8));

 //二进制转十进制      Integer.valueOf("0101",2).toString();
 //二进制转八进制        Integer.toOctalString(Integer.parseInt("0101", 2));
 //二进制转十六进制    Integer.toHexString(Integer.parseInt("0101", 2));

 5. 升级了AS之后，打包应用发现POST提交的json字段名被混淆了，想到会不会是混淆设置的问题，但是以前打包也没出现过这问题啊，不知道是不是新版AS打包配置修改了。 治标解决办法如下： 但不是治本的
#该包下所有的类不被混淆
-keep public class com.packageName.**{*;}

6. //设置dialog背景透明,要在dialog.show()之后执行
Window window = dialog.getWindow();
window.setBackgroundDrawableResource(R.color.colorTransparent);

7. id命名可直接写在strings.xml文件中
<item name="search_book_contents_succeeded" type="id"/>
<string name="app_name">Lib-zxing</string>

8. 蓝牙协议之所以被很多厂商所接受，就是因其功能很完善，实现灵活性很高，蓝牙模块只要实现蓝牙协议规定的功能即可，而代码如何写这个就是厂商自己的事情了，所以肯定会有兼容性能问题，兼容性问题总结下来就三个：扫描不到、连接不上、收不到数据，企业采购蓝牙模块一定要做好验收工作

9. java android 将 List中元素互换位置:Collections.swap(data,index1,index2);

10. java中线程分为两种类型：用户线程和守护线程。通过Thread.setDaemon(false)设置为用户线程；通过Thread.setDaemon(true)设置为守护线程。如果不设置次属性，默认为用户线程。

用户线程和守护线程的区别：
- 主线程结束后用户线程还会继续运行,JVM存活；主线程结束后守护线程和JVM的状态又下面第2条确定。
- 如果没有用户线程，都是守护线程，那么JVM结束（随之而来的是所有的一切烟消云散，包括所有的守护线程）。

11. OkHttp 3.13起最低支持Android 5.0了,为了安全为了HTTPS
Today we’re releasing OkHttp 3.13. With this update we’re bumping the project’s requirements from this:
Android 2.3+ / API 9+ (released December 2010)
Java 7+ (released July 2011)
to this:
Android 5.0+ / API 21+ (released November 2014)
Java 8+ (released March 2014)

如果想支持4.4及以下系统而不crash，就要用OkHttp的3.12版本及以下了

12. 游戏三大要素：（让玩家欲罢不能的陷阱）
Points（积分）
Badges（勋章, 成就系统）
Leaderboards（排行榜）

13. “高成本方案”能够带来多少的收益提升
按照我的一些经验，如果成本上提高1毛钱，到了消费者手里很可能就是多了1块钱，我刚入行的时候，一直觉得一个wifi模块不就10块钱么，为什么不加上呢？后来算算，10块钱的成本，工厂要增加安装的工位、增加检测的工位、增加检测的设备和软硬件，工人工资，企业利润、经销商利润，这10快钱成本，到了消费者手里很可能就是100-200的价格了。如果单纯是为了提升一点点用户体验，产品都卖不出去了，那这个自然是没有必要的了。
--- 来自网友

14. 技术氛围好的公司是怎样的？
code review
技术方案评审
产品方案评审
每周技术分享
技术周报
丰富的技术资料库，鼓励员工在内网发布技术文章（奖金），每周都有技术分享，定期发布技术汇总刊物，购买相关领域知名的期刊或会议资料，等等
技术氛围好就是同事厉害、Leader 也厉害。

吃饭的时候萌新会问问题，大佬会讨论看到什么好玩的技术，或者技术圈子里面的新闻。
——而不是房子、装修、房子、装修。

15. 《学习之道》心得。
关于复习：
1.学完之后回忆知识（有助于形成知识组块），比机械重复的效果更好。 最后可以去画出思维导图巩固
2.在多个不同的场所去尝试回忆知识，可以减少你对特定场所的依赖（比如考场上回忆不出知识点）
关于笔记：不要大量加下划线，仅标记关键词即可，在关键地方加笔记效果更好.
关于学习效果：自测是一个很有效的方法（比如做题），而一味单纯地反复阅读很可能是自欺欺人。
关于知识难点：我们应该把精力集中在你认为困难的地方（可以练习），而不是一直反复学习简单的点。应该 难-易-难-易来回学习。考试先做难题，遇到难题卡住了就先切换到简单题（在此期间你的大脑其实也在继续思考着之前的难题），再反复切换
思维导图+费曼学习法 （温故而知新，可以为师矣）

16. 
- 十六进制数以数字零开始，0x中的x在c语言中是不分大小写的，即0x与0X等价。
- 八进制以英文字母o开头，在c语言里也是不分大小，即o与O等价。

17. 为什么要有包装类型？比如 int和Integer
- int 是基本类型而不是对象，无法调用它的一些方法，Integer可以调用 Integer.parseInt() 等方法
- 像List、Map等容器设置装的数据类型时要用的是类，而不是基本类型，比如 List<Integer>

18. 如何将SQLite数据库(dictionary.db文件)与apk文件一起发布?
可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res aw目录中

19. ContentProvider的主要还是用于数据共享，其可以对Sqlite，SharePreferences，File等进行数据操作用来共享数据。而sql的可以理解为数据库的一门语言，可以使用它完成CRUD等一系列的操作。而ContentProvider是一套封装好的接口

20. 当内存紧张时释放内存，避免在Bitmap上浪费内存
Android系统加载图片是先要把图片转换为Bitmap对象然后再传到ImageView里头显示的。
当我们读取一个Bitmap图片的时候，有一点一定要注意，就是千万不要去加载不需要的分辨率。在一个很小的ImageView上显示一张高分辨率的图片不会带来任何视觉上的好处，但却会占用我们相当多宝贵的内存。需要仅记的一点是，将一张图片解析成一个Bitmap对象时所占用的内存并不是这个图片在硬盘中的大小，可能一张图片只有100k你觉得它并不大，但是读取到内存当中是按照像素点来算的，比如这张图片是1500*1000像素，使用的ARGB_8888颜色类型，那么每个像素点就会占用4个字节，总内存就是1500*1000*4字节，也就是5.7M，这个数据看起来就比较恐怖了。

21. singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。
singleTask适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。之前打开过的页面，打开之前的页面就ok，不再新建。
singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。

22. 内存优化：Android中容易内存溢出的部分，就是图片的加载，我们可以使用图片的压缩加上使用LruCache缓存的目的来控制图片所能够使用的内存。
还有对于比较耗资源的对象及时的关闭，例如Database Conn , 各种传感器 ， Service 等等。
还有Handler、Context、Dialog等内存泄漏。
-  数据库的cursor没有关闭
- 构造adapter时,没有使用缓存contentview
   衍生listview的优化问题-----减少创建view的对象,充分使用contentview,可以使用一静态类来优化处理getview的过程/
- Bitmap对象不使用时采用recycle()释放内存
- activity中的对象的生命周期大于activity

23. Android 在Activity中调用finish()方法，会走哪些生命周期方法？
看标题问题，你可能会想：这还不简单，在程序中调用finish()，Activity会继续调用onPause()、onStop()、onDestroy()方法。
其实错了，有坑。

1、在Activity的onCreate()中调用finish()方法，则执行的生命周期方法顺序为：
onCreate() -> onDestroy()

2、在Activity的onStart()中调用finish()方法，则执行的生命周期方法顺序为：
onCreate() -> onStart() -> onStop() -> onDestroy()

3、在Activity的onResume()或onPostResume()中调用finish()方法，则执行的生命周期方法顺序为：
onCreate() -> onStart() -> onResume() -> onPostResume() -> onPause() -> onStop() -> onDestroy()
其他方法可以正常执行。

24. ViewRootImpl的创建在onResume方法回调之后，而我们一开篇是在onCreate方法中创建了子线程并访问UI，在那个时刻，ViewRootImpl是没有创建的，无法检测当前线程是否是UI线程，所以程序没有崩溃一样能跑起来，而之后修改了程序，让线程休眠了200毫秒后，程序就崩了。很明显200毫秒后ViewRootImpl已经创建了，可以执行checkThread方法检查当前线程。

其次谷歌推荐如果子线程需要修改UI可以使用handler，这样的队列设也是考虑到并发，效率的体现。

为什么 android 会设计成只有创建 ViewRootImpl 的原始线程才能更改 ui 呢？这就要说到 Android 的单线程模型了，因为如果支持多线程修改 View 的话，由此产生的线程同步和线程安全问题将是非常繁琐的，所以 Android 直接就定死了，View 的操作必须在创建它的 UI 线程，从而简化了系统设计。

25. 威斯敏斯特教堂地下室的无名墓碑上，写着的一段话：“当我年轻的时候，雄心勃勃，梦想着改变世界；当我历经世间沧桑，我发现不能改变这个世界，于是我将目光缩短一些，决定只改变我的国家；当我进入暮年，我发现不能改变我的国家，于是决定改变我的家庭，但遗憾的是他们也不接受我的改变；当我躺在病床上，行将就木时，我突然意识到，如果当初我先改变自己，也许在我的影响之下，我就能改变我的家庭，然后在家人的鼓励和帮助之下，也许我就能为我的国家做一些事情，说不定，也许我连整个世界也改变”，坐而论道不如起而行，改变从自己做起。


26. 
引自网友：
```
全栈工程师是指，一个能处理数据库、服务器、系统工程和客户端的所有工作的工程师。根据项目的不同，客户需要的可能是移动栈、Web栈，或者原生应用程序栈。                                  
 其实，“全栈”指的是为了完成一个项目，所需要的一系列技术的集合。“栈”是指一系列子模块的集合。这些软件子模块或者组件组合在一起即可实现既定功能，不再需要其他模块。

优势：全栈工程师的技术发展是横向的，涉猎技术很广，能快速的运用他所掌握的技术知识开发出产品原型。因为他们视野更宽阔，思维更活跃，对技术和产品都十分敏感，对于任何技术或设计，他总是有话可说。可以对团队中的每一个人都提供有益的帮助，能大大减少团队人员沟通、技术对接的时间和技术成本。所以他们当中，很多人成为了创业者或者在创业公司担任技术合伙人。
 劣势：正是由于横向的技术发展，导致全栈工程师往往博而不精。大多数自称为“全栈”的工程师，都停留在一种浅尝辄止的“略懂”的境界。至于具体如何实现，如何让架构更适合后面阶段的模块化开发，那就真不知道了。

一个真正的全栈工程师，目标只有一个：创业。

写的很好。 全栈工程师在小公司或者初创公司更能发挥能量。 而在大公司，都是一个萝卜一个坑，很难发挥全部 潜力，除非干上技术总监之类的职位。
当技术型管理或创业知识全面确实有一点优势。 不过要在一个领域深入真的很难，全栈工程师更容易装逼一点。要装专家太难了，一问就穿帮了。很多人被动的成全这样是因为根本无法在任一领域深入。所有的武功都练到一半容易，要把一种练到顶级才难。

在我眼里，全栈工程师是下能玩硬件和驱动，上能写网页和js，中间能玩转服务器和数据库，没事还能自己做个安卓或iOS App， 对IT系统有着全面深刻的理解，熟悉所负责项目的整体技术栈。
我认为全栈工程师的特质应该有以下几个：强大的解决问题能力；广博的知识面，快速学习能力，不给自己设限，主动学习新技术；熟悉多种编程语言，熟悉整个系统从上到下的技术实现。

全栈不是说全部精通，那不是全栈，那是超人。。。全栈是指，围绕着你最核心的业务技术周边一圈技术栈你都要熟悉，必要的时候都能够卷起袖管操起来。
请不要把什么都会了一点就说是全栈，也不要觉得只做一个领域的事情就能成专家。
一专多能最好。
人的精力是有限的，不排除少数天才能专精多个领域，但大多数人能深耕一个领域中的一个技术方向就已经很不容易了。

全栈工程师适用下面这些场合：
个人项目或创业公司，刚起步，团队小，一个人可以把产品打造出可用的雏形；
作为精通前后端多个领域的工程师，在团队中任何开发角色都能够即插即用；
作为团队Leader，掌控开发方向，编写核心代码，同时能指导其他人的工作。

技多不压身，然后再具备那么一两个杀手锏，这样多好。
先说在前头，专精在大公司好找工作，全栈在创业公司好找工作
```