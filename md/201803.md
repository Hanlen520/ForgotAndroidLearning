# 每月整理-2018年3月
1. 产品设计三件事：搭架子、定流程、抠细节。

2. 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来 的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序 列化，否则就会出现序列化版本不一致的异常。 如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，未作更改的类，就需要显式地定义一个名为serialVersionUID，类型为long的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。

3. 作为一个项目owner，即使你只承担了1%的原因占比，你也应该负100%的责任。如果我是站在一个项目owner的角度，从自己这个原因出发，我完全可以去推动其他人，去更早的思考项目的投产闭环：调研目前的现状和原因，提出解决策略；哪怕有些策略不是产品侧能解决的；忙不是借口，身兼多个项目不是理由，如果是自己的重点项目，就一定要想办法超出预期。想明白这个问题，你才能从功能负责人成长为业务负责人。

4. AppID、AppKey、AppSecret到底是什么
- AppID：应用的唯一标识
- AppKey：公匙（相当于账号）
- AppSecret：私匙（相当于密码）
- token：令牌（过期失效）

5. BRD 商业需求文档>MRD 市场需求文档 >PRD 产品需求文档

6. 总之，就一句话，会挣钱的人一定是会投资的人。我一直认为，最宝贵的财富并不是钱，而是你的时间，时间比钱更宝贵，因为钱你不用还在那里，而时间你不用就浪费掉了。你把你的时间投资在哪些地方，就意味着你未来会走什么样的路。所以，利用好你的时间，投到一些有意义的地方吧。

7. 性能问题一般归结为三类：
- UI卡顿和稳定性:这类问题用户可直接感知，最为重要；
- 内存问题：内存问题主要表现为内存泄露，或者内存使用不当导致的内存抖动。如果存在内存泄露，应用会不断消耗内存，易导致频繁gc使系统出现卡顿，或者出现OOM报错；内存抖动也会导致UI卡顿。
-  耗电问题：会影响续航，表现为不必要的自启动，不恰当持锁导致系统无法正常休眠，系统休眠后频繁唤醒系统等；

8. 应用UI卡顿常见原因
- 人为在UI线程中做轻微耗时操作，导致UI线程卡顿；
-  布局Layout过于复杂，无法在16ms内完成渲染；
-  同一时间动画执行的次数过多，导致CPU或GPU负载过重；
- View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；
-  View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；
-  内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；
-  冗余资源及逻辑等导致加载和执行缓慢；
-  臭名昭著的ANR；

9. 谨慎编写Native
Android JVM相关知识，可参看: ART、Dalvik
Android JNI、NDK相关知识，可参看: NDK
写native性能不一定更好，Native并不是用于使得性能更好，而是用于有些已经存在的库是使用native语言实现的，我们需要引入Android，这时才使用。

10. 开发前和后台、UI定义好一些命名规范，方便统一命名，理解，尤其是调接口方便

11. 为什么需要自定义View？
- 现有的View满足不了你的需求，也没有办法从已有控件派生一个出来；界面元素需要自己绘制。
- 现有View可以满足要求，把它做成自定义View只是为了抽象：为这个自定义View提供若干方法，方便调用着操纵View。通常做法是派生一个已有View，或者结合xml文件直接inflate。
- 复用已有View是最最常用也最有效的自定义View方式，必须熟练使用。
